From a6a811faa2e07d3b2964d80c9f813e69fccdd5c5 Mon Sep 17 00:00:00 2001
From: Artur Gebicz <a.gebicz@metrological.com>
Date: Wed, 22 Nov 2023 13:19:46 +0000
Subject: [PATCH 10/11] Await for samples with correct timestamp after seek

Fix for macroblocks issue.  Cobalt seeks for video to key frame so to
avoid dropping late frames put pipeline in PAUSED when late samples
incoming.
---
 .../wpe/shared/player/player_internal.cc      | 57 +++++++++++++++++--
 1 file changed, 52 insertions(+), 5 deletions(-)

diff --git a/third_party/starboard/wpe/shared/player/player_internal.cc b/third_party/starboard/wpe/shared/player/player_internal.cc
index f83127222f..77965a6cc8 100755
--- a/third_party/starboard/wpe/shared/player/player_internal.cc
+++ b/third_party/starboard/wpe/shared/player/player_internal.cc
@@ -848,6 +848,7 @@ class PlayerImpl : public Player, public DrmSystemOcdm::Observer {
   mutable gint64 cached_position_ns_{0};
   mutable SbTime position_update_time_us_{0};
   PendingBounds pending_bounds_;
+  bool sample_after_key_frame_ready_{true};
 };
 
 PlayerImpl::PlayerImpl(SbPlayer player,
@@ -1472,6 +1473,37 @@ void PlayerImpl::WriteSample(SbMediaType sample_type,
                 "Adjust impl. to handle more samples after changing samples"
                 "count");
   DCHECK(number_of_sample_infos == kMaxNumberOfSamplesPerWrite);
+
+  bool check_timestamp = false;
+  {
+    ::starboard::ScopedLock lock(mutex_);
+    check_timestamp = (sample_type == kSbMediaTypeVideo) && !sample_after_key_frame_ready_;
+  }
+
+  if (check_timestamp)
+  {
+    const SbTime seek_timestamp = seek_position_ * kSbTimeNanosecondsPerMicrosecond;
+    const SbTime sample_timestamp = sample_infos[0].timestamp * kSbTimeNanosecondsPerMicrosecond;
+    const bool late_sample = seek_position_ != kSbTimeMax && (seek_timestamp > sample_timestamp);
+    if (late_sample)
+    {
+      // Request next sample to reach this one with matching timestamp to seek position
+      DispatchOnWorkerThread(new DecoderStatusTask(
+        decoder_status_func_, player_, ticket_, context_,
+        kSbPlayerDecoderStateNeedsData, MediaType::kVideo));
+
+      // Put pipeline in PAUSED if incoming samples are late in context of seek position
+      if ((GST_STATE(pipeline_) == GST_STATE_PLAYING && GST_STATE_PENDING(pipeline_) != GST_STATE_PAUSED))
+      {
+        ChangePipelineState(GST_STATE_PAUSED);
+      } 
+    }
+    else{
+      ::starboard::ScopedLock lock(mutex_);
+      sample_after_key_frame_ready_ = true;
+    }
+  }
+
   GstBuffer* buffer =
       gst_buffer_new_allocate(nullptr, sample_infos[0].buffer_size, nullptr);
   gst_buffer_fill(buffer, 0, sample_infos[0].buffer,
@@ -1490,11 +1522,17 @@ void PlayerImpl::WriteSample(SbMediaType sample_type,
   RecordTimestamp(sample_type,
                   sample_infos[0].timestamp * kSbTimeNanosecondsPerMicrosecond);
 
+  bool correct_timestamp_ready = false;
+  {
+    ::starboard::ScopedLock lock(mutex_);
+    correct_timestamp_ready = sample_after_key_frame_ready_;
+  }
+
   if (MinTimestamp(nullptr) == GST_BUFFER_TIMESTAMP(buffer) &&
       GST_STATE(pipeline_) == GST_STATE_PAUSED &&
       (GST_STATE_PENDING(pipeline_) == GST_STATE_VOID_PENDING ||
        GST_STATE_PENDING(pipeline_) == GST_STATE_PAUSED) &&
-      rate_ > .0) {
+      rate_ > .0 && correct_timestamp_ready) {
     GST_TRACE("Moving to playing for %" GST_TIME_FORMAT,
               GST_TIME_ARGS(GST_BUFFER_TIMESTAMP(buffer)));
     ChangePipelineState(GST_STATE_PLAYING);
@@ -1589,9 +1627,6 @@ void PlayerImpl::Seek(SbTime seek_to_timestamp, int ticket) {
     if (GST_STATE(pipeline_) < GST_STATE_PAUSED) {
       GST_INFO("Delaying seek.");
       if (state_ == State::kInitialPreroll) {
-        DispatchOnWorkerThread(new PlayerStatusTask(player_status_func_,
-                                                    player_, ticket_, context_,
-                                                    kSbPlayerStatePresenting));
         DispatchOnWorkerThread(new PlayerStatusTask(player_status_func_,
                                                     player_, ticket_, context_,
                                                     kSbPlayerStatePrerolling));
@@ -1607,6 +1642,10 @@ void PlayerImpl::Seek(SbTime seek_to_timestamp, int ticket) {
               kSbPlayerDecoderStateNeedsData, MediaType::kAudio));
         }
       }
+      else
+      {
+        sample_after_key_frame_ready_ = false;
+      }
       is_seek_pending_ = true;
       return;
     }
@@ -1650,7 +1689,15 @@ bool PlayerImpl::SetRate(double rate) {
   if (rate == .0) {
     ChangePipelineState(GST_STATE_PAUSED);
   } else if (rate == 1. && (current_rate == 1. || current_rate == .0)) {
-    ChangePipelineState(GST_STATE_PLAYING);
+    bool correct_timestamp_ready = true;
+    {
+      ::starboard::ScopedLock lock(mutex_);
+      correct_timestamp_ready = sample_after_key_frame_ready_;
+    }
+    if (correct_timestamp_ready)
+    {
+      ChangePipelineState(GST_STATE_PLAYING);
+    }
   } else {
     ChangePipelineState(GST_STATE_PLAYING);
     {
-- 
2.17.1

