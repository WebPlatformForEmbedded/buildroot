--- a/Makefile.in
+++ b/Makefile.in
@@ -9,7 +9,7 @@
 # dbclient functionality, and includes the progress-bar functionality in scp.
 
 ifndef PROGRAMS
-	PROGRAMS=dropbear dbclient dropbearkey dropbearconvert
+	PROGRAMS=dropbear
 endif
 
 STATIC_LTC=libtomcrypt/libtomcrypt.a
@@ -17,6 +17,8 @@ STATIC_LTM=libtommath/libtommath.a
 
 LIBTOM_LIBS=@LIBTOM_LIBS@
 
+DROPBEAR_SERVER_LIB=libdropbear.so
+
 ifeq (@BUNDLED_LIBTOM@, 1)
 LIBTOM_DEPS=$(STATIC_LTC) $(STATIC_LTM) 
 LIBTOM_CLEAN=ltc-clean ltm-clean
@@ -55,6 +57,7 @@ CLISVROBJS=common-session.o packet.o common-algo.o common-kex.o \
 			tcp-accept.o listener.o process-packet.o dh_groups.o \
 			common-runopts.o circbuffer.o list.o netio.o chachapoly.o gcm.o
 
+
 KEYOBJS=dropbearkey.o
 
 CONVERTOBJS=dropbearconvert.o keyimport.o
@@ -98,6 +101,9 @@ datarootdir = @datarootdir@
 bindir=@bindir@
 sbindir=@sbindir@
 mandir=@mandir@
+libdir = @libdir@
+includedir = @includedir@
+pkgconfigdir = $(libdir)/pkgconfig
 
 .DELETE_ON_ERROR:
 
@@ -107,9 +113,10 @@ RANLIB=@RANLIB@
 STRIP=@STRIP@
 INSTALL=@INSTALL@
 CPPFLAGS=@CPPFLAGS@
-CFLAGS+=-I. -I$(srcdir) $(CPPFLAGS) @CFLAGS@
+CFLAGS+=-I. -I$(srcdir) $(CPPFLAGS) @CFLAGS@ -fPIC
 LIBS+=@LIBS@
 LDFLAGS=@LDFLAGS@
+ARFLAGS=rcT
 
 EXEEXT=@EXEEXT@
 
@@ -131,12 +138,15 @@ export RANLIB AR STRIP
 
 ifeq ($(STATIC), 1)
 	LDFLAGS+=-static
+else
+	LDFLAGS +=-shared
 endif
 
 ifeq ($(MULTI), 1)
 	TARGETS=dropbearmulti$(EXEEXT)
 else
-	TARGETS=$(PROGRAMS)
+	TARGETS=$(DROPBEAR_SERVER_LIB)
+	CFLAGS+=-DDEBUG_TRACE
 endif
 
 # for the scp progress meter. The -D doesn't affect anything else.
@@ -197,6 +207,7 @@ dbclient: $(dbclientobjs)
 dropbearkey: $(dropbearkeyobjs)
 dropbearconvert: $(dropbearconvertobjs)
 
+
 dropbear: $(HEADERS) $(LIBTOM_DEPS) Makefile
 	$(CC) $(LDFLAGS) -o $@$(EXEEXT) $($@objs) $(LIBTOM_LIBS) $(LIBS) @CRYPTLIB@ $(PLUGIN_LIBS)
 
@@ -210,6 +221,11 @@ dropbearkey dropbearconvert: $(HEADERS) $(LIBTOM_DEPS) Makefile
 scp: $(SCPOBJS)  $(HEADERS) Makefile
 	$(CC) $(LDFLAGS) -o $@$(EXEEXT) $(SCPOBJS)
 
+#dropbear server as a lib needs libcurl to communicate to Thunder through jsonrpc()
+$(DROPBEAR_SERVER_LIB):$(LIBTOM_LIBS) $(dropbearobjs)
+	$(CC) $(LDFLAGS) -o $@ $(dropbearobjs) $(LIBTOM_LIBS) $(LIBS) 
+
+
 
 # multi-binary compilation.
 MULTIOBJS=
@@ -251,7 +267,7 @@ clean: $(LIBTOM_CLEAN) thisclean
 thisclean:
 	-rm -f dropbear$(EXEEXT) dbclient$(EXEEXT) dropbearkey$(EXEEXT) \
 			dropbearconvert$(EXEEXT) scp$(EXEEXT) scp-progress$(EXEEXT) \
-			dropbearmulti$(EXEEXT) *.o *.da *.bb *.bbg *.prof
+			*.o *.da *.bb *.bbg *.prof libdropbear.pc $(DROPBEAR_SERVER_LIB)
 
 distclean: clean tidy
 	-rm -f config.h




--- /dev/null
+++ b/libdropbear.h
@@ -0,0 +1,66 @@
+#ifndef __LIBDROPBEAR_H
+#define __LIBDROPBEAR_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define	IPADDRESSLENGTH		16
+#define	TIMESTAMPLENGTH		26
+
+struct client_info{
+        int  pid;
+        int fileDescriptor;               // handle to the client session
+        char ipaddress[IPADDRESSLENGTH];  //Client IPv4 address
+        char timestamp[TIMESTAMPLENGTH];  //timestamp of the received client
+};
+
+
+/**
+ * @brief Activate dropbear server
+ * @return 0 if successfull
+ *         1 in case of error caused by mutexes,
+ *         2 in case of error during the creation of a new working thread,
+ *         3 if the dropbear server uis already runnning
+ */
+uint32_t activate_dropbear(const char*);   
+
+/**
+ * @brief Deactivate dropbear server
+ * @return 0 if successfull, 
+ *         1 in case of failure of in case dropbear was not running
+ */
+uint32_t deactivate_dropbear();      
+
+/**
+ * @brief get Number of active ssh sessions
+ * @return number of active sessions
+ */
+uint32_t get_active_sessions_count();
+
+/**
+ * @brief Get details about all open sessions
+ * @param connectedclientsContainer pointer to a container where to store all sessions informations
+ * @param size_t size of the container(number of struct of type client_info)
+ * @return 0 if successfull, 
+ *         1 for any error(example dropbear is not active)
+ */
+uint32_t get_active_sessions_info(struct client_info* connectedclientsContainer, size_t number);
+
+
+/**
+ * @brief Close ssh session with specific pid
+ * @param pid pid of the ssh client session
+ * @return 0 if successfull, 
+ *         1 if pid does not exist,
+ *         2 is dropbear is inactive
+ */
+uint32_t close_client_session(int pid);
+
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
--- a/configure.ac	2016-07-21 17:17:09.000000000 +0200
+++ b/configure.ac	2021-08-20 07:58:26.063608000 +0200
@@ -863,6 +863,9 @@ AC_CONFIG_HEADER(config.h)
 AC_CONFIG_FILES(Makefile $LIBTOM_FILES)
 AC_OUTPUT
 
+AC_CONFIG_FILES(libdropbear.pc)
+AC_OUTPUT
+
 AC_MSG_NOTICE()
 if test $BUNDLED_LIBTOM = 1 ; then
 AC_MSG_NOTICE([Using bundled libtomcrypt and libtommath])

diff --git a/libdropbear.pc.in b/libdropbear.pc.in
new file mode 100644
index 0000000..2d3ce41
--- /dev/null
+++ b/libdropbear.pc.in
@@ -0,0 +1,11 @@
+prefix=@prefix@
+exec_prefix=@exec_prefix@
+libdir=@libdir@
+includedir=@includedir@
+
+Name: libdropbear
+Version: @PACKAGE_VERSION@
+Description: Dropbear SSH
+URL: http://matt.ucc.asn.au/dropbear/releases
+Libs: -L${libdir} -ldropbear
+Cflags: -I${includedir}


diff --git a/linkedlist.h b/linkedlist.h
new file mode 100644
index 0000000..8da6057
--- /dev/null
+++ b/linkedlist.h
@@ -0,0 +1,169 @@
+/**
+ * info: linkedlist.h file is derived from the
+ * linux-5.2.1/include/linux/list.h
+ * https://www.kernel.org
+ *
+ */
+
+#ifndef _LINKED_LIST_H
+#define _LINKED_LIST_H
+#include <stdio.h>
+
+/**
+ * Get offset of a member
+ */
+#define offsetoff(TYPE, MEMBER) ((size_t) &((TYPE *)0)->MEMBER)
+
+/**
+ * Casts a member of a structure out to the containing structure
+ * @param ptr        the pointer to the member.
+ * @param type       the type of the container struct this is embedded in.
+ * @param member     the name of the member within the struct.
+ *
+ */
+#define container_of(ptr,type,member) ({                                \
+                const typeof( ((type *)0)->member ) *__mptr = (ptr);    \
+                (type *)( (char *)__mptr - offsetoff(type,member) );})
+/*
+ * These are non-NULL pointers that will result in page faults
+ * under normal circumstances, used to verify that nobody uses
+ * non-initialized list entries.
+ */
+#define LIST_POISON1  ((void *) 0x00100100)
+#define LIST_POISON2  ((void *) 0x00200200)
+
+
+#define WRITE_ONCE(ptr,value)   (ptr=value)
+
+typedef _Bool                   bool;
+
+enum {
+        false   = 0,
+        true    = 1
+};
+
+
+struct list_head {
+        struct list_head *next, *prev;
+};
+
+/*
+ * Simple doubly linked list implementation.
+ *
+ * Some of the internal functions ("__xxx") are useful when
+ * manipulating whole lists rather than single entries, as
+ * sometimes we already know the next/prev entries and we can
+ * generate better code by using them directly rather than
+ * using the generic single-entry routines.
+ */
+
+static inline void INIT_LIST_HEAD(struct list_head *list)
+{
+	WRITE_ONCE(list->next, list);
+	list->prev = list;
+}
+
+#ifdef CONFIG_DEBUG_LIST
+extern bool __list_add_valid(struct list_head *new,
+			      struct list_head *prev,
+			      struct list_head *next);
+extern bool __list_del_entry_valid(struct list_head *entry);
+#else
+static inline bool __list_add_valid(struct list_head *new,
+				struct list_head *prev,
+				struct list_head *next)
+{
+	return true;
+}
+static inline bool __list_del_entry_valid(struct list_head *entry)
+{
+	return true;
+}
+#endif
+
+/*
+ * Insert a new entry between two known consecutive entries.
+ *
+ * This is only for internal list manipulation where we know
+ * the prev/next entries already!
+ */
+static inline void __list_add(struct list_head *new,
+			      struct list_head *prev,
+			      struct list_head *next)
+{
+	if (!__list_add_valid(new, prev, next))
+		return;
+
+	next->prev = new;
+	new->next = next;
+	new->prev = prev;
+	WRITE_ONCE(prev->next, new);
+}
+
+
+/**
+ * list_add_tail - add a new entry
+ * @new: new entry to be added
+ * @head: list head to add it before
+ *
+ * Insert a new entry before the specified head.
+ * This is useful for implementing queues.
+ */
+static inline void list_add_tail(struct list_head *new, struct list_head *head)
+{
+	__list_add(new, head->prev, head);
+}
+
+/*
+ * Delete a list entry by making the prev/next entries
+ * point to each other.
+ *
+ * This is only for internal list manipulation where we know
+ * the prev/next entries already!
+ */
+static inline void __list_del(struct list_head * prev, struct list_head * next)
+{
+	next->prev = prev;
+	WRITE_ONCE(prev->next, next);
+}
+
+/**
+ * list_del - deletes entry from list.
+ * @entry: the element to delete from the list.
+ * Note: list_empty() on entry does not return true after this, the entry is
+ * in an undefined state.
+ */
+static inline void __list_del_entry(struct list_head *entry)
+{
+	if (!__list_del_entry_valid(entry))
+		return;
+
+	__list_del(entry->prev, entry->next);
+}
+
+static inline void list_del(struct list_head *entry)
+{
+	__list_del_entry(entry);
+	entry->next = LIST_POISON1;
+	entry->prev = LIST_POISON2;
+}
+
+/**
+ * list_entry - get the struct for this entry
+ * @ptr:	the &struct list_head pointer.
+ * @type:	the type of the struct this is embedded in.
+ * @member:	the name of the list_head within the struct.
+ */
+#define list_entry(ptr, type, member) \
+	container_of(ptr, type, member)
+
+/**
+ * list_for_each        -       iterate over a list
+ * @pos:        the &struct list_head to use as a loop cursor.
+ * @head:	the head for your list.
+ */
+#define list_for_each(pos, head) \
+	for (pos = (head)->next; pos != (head); pos = pos->next)
+
+#endif
+


diff --git a/svr-main.c b/svr-main.c

@@ -30,16 +30,55 @@
 #include "runopts.h"
 #include "dbrandom.h"
 #include "crypto_desc.h"
+#include <pthread.h>
+#include "libdropbear.h"
+#include "linkedlist.h"
+#include <poll.h>
+#include <stddef.h>
 
 static size_t listensockets(int *sock, size_t sockcount, int *maxfd);
 static void sigchld_handler(int dummy);
 static void sigsegv_handler(int);
 static void sigintterm_handler(int fish);
+
+//Functions used to build dropbear as a sharedlib
+void init_dropbear(int argc, char ** argv);
+void free_client_info();
+static int setargs(char *args, char **argv);
+char **parsedargs(char *args, int *argc);
+void freeparsedargs(char **argv);
+
+
+struct list_head client_connections_info;  //list of all connected SSH clients
+
+struct active_clients{
+	struct client_info info;
+	struct list_head client_list;
+};
+
+static int pluginActivated = 0;
+static pthread_t threadID;
+static pthread_t children_routine_thread_id;
+static bool stop_server = false;  // a flag to stop the main server therad
+static bool fd_children_update =false ;  
+pthread_mutex_t lock;
+
+
+
+
+// user signal to close an SSH session
+static void sigusr1_handler(int signal) {
+	TRACE(("libdropbear:sigusr1_handler received %d  ",signal));
+	ses.exitflag = 1;
+}
+
+
 #if INETD_MODE
 static void main_inetd(void);
 #endif
 #if NON_INETD_MODE
-static void main_noinetd(void);
+static void* main_noinetd(void* nonused);
+static void* track_child_process_routine(void* nonused);   //  function to track child process
 #endif
 static void commonsetup(void);
 
@@ -49,32 +88,371 @@ int dropbear_main(int argc, char ** argv)
 #else
 int main(int argc, char ** argv)
 #endif
+{
+
+	int result = 0;
+
+    int character;
+    do {
+        character = toupper(getc(stdin));
+
+        switch (character) {
+        case 'A': {
+			activate_dropbear("-R -v -p 1500");
+			break;
+		}
+		case 'B': {
+			deactivate_dropbear();
+			break;
+		}
+		case 'C': {
+			NumberOfActiveSessions();
+			break;
+		}
+		case 'D': {
+			DetailsActiveSessions();
+			break;
+		}
+		case 'S': {
+			int myInt;
+			scanf(" %d", &myInt);
+			close_client_session(myInt);
+			break;
+		}
+           
+        case '?': {
+            break;
+        }
+        default:
+            break;
+        }
+    } while (character != 'Q');
+
+
+
+    return 0;
+
+}
+#endif
+
+
+// Here we define the api functions when building as a shared lib
+ void init_dropbear(int argc, char ** argv)
 {
 	_dropbear_exit = svr_dropbear_exit;
 	_dropbear_log = svr_dropbear_log;
-
 	disallow_core();
-
 	/* get commandline options */
 	svr_getopts(argc, argv);
+	INIT_LIST_HEAD(&client_connections_info);
+}
 
-#if INETD_MODE
-	/* service program mode */
-	if (svr_opts.inetdmode) {
-		main_inetd();
-		/* notreached */
+static int setargs(char *args, char **argv)
+{
+	int count = 0;
+	while (isspace(*args)) ++args;
+	while (*args) {
+		if (argv) argv[count] = args;
+		while (*args && !isspace(*args)) ++args;
+		if (argv && *args) *args++ = '\0';
+		while (isspace(*args)) ++args;
+		count++;
 	}
-#endif
+	return count;
+}
 
-#if NON_INETD_MODE
-	main_noinetd();
-	/* notreached */
-#endif
+char **parsedargs(char *args, int *argc)
+{
+	char **argv = NULL;
+	int    argn = 0;
+
+	if (args && *args
+			&& (args = strdup(args))
+			&& (argn = setargs(args,NULL))
+			&& (argv = malloc((argn+1) * sizeof(char *)))) {
+		*argv++ = args;
+		argn = setargs(args,argv);
+	}
 
-	dropbear_exit("Compiled without normal mode, can't run without -i\n");
-	return -1;
+	if (args && !argv) free(args);
+	*argc = argn;
+	return argv;
 }
-#endif
+
+void freeparsedargs(char **argv)
+{
+	if (argv) {
+		free(argv[-1]);
+		free(argv-1);
+	}
+}
+
+
+uint activate_dropbear(const char* string)
+{
+	uint result = 0;
+	int argc,len;
+	char **argv;
+	char *str;
+
+	if (pthread_mutex_init(&lock, NULL) != 0)
+	{
+		result= 1;
+	}
+	if (result==0){	
+		pthread_mutex_lock(&lock);
+		if(pluginActivated == 0)
+		{
+			pthread_mutex_unlock(&lock);
+			TRACE(("libdropbear Activating drop bear\n"))
+			len = strlen("dropbear ")+strlen(string)+1;
+			str=(char *)malloc(len*sizeof(char));
+			strncpy(str, "dropbear ", strlen("dropbear "));
+			strncpy(str+strlen("dropbear "), string, strlen(string)+1);
+			argv = parsedargs(str,&argc);
+			free(str);
+			/*for (int i = 0; i < argc; i++)
+				printf("argv[%d] = %s\n", i, argv[i]);*/
+
+			init_dropbear(argc, argv);
+			freeparsedargs(argv);
+
+			if (result ==0) {
+				if(pthread_create(&threadID,NULL,main_noinetd,NULL)!=0) {
+					result=2;
+				} else {
+					pthread_mutex_lock(&lock);
+					pluginActivated = 1; //server is indeed running on a separate thread
+					pthread_mutex_unlock(&lock);
+				}
+			}
+				
+		} else {
+			pthread_mutex_unlock(&lock);
+			TRACE(("libdropbear : Dropbear is already running, stop it first!"));
+			result = 3;
+		}
+	}
+	return result;
+}
+
+uint deactivate_dropbear()
+{
+	uint result = 1;
+	TRACE(("libbdropbear : Deactivating dropbear"));
+	pthread_mutex_lock(&lock);
+	if(pluginActivated == 1)
+	{
+		stop_server = true;
+		pthread_mutex_unlock(&lock);
+		pthread_join(threadID, 0);
+		pthread_join(children_routine_thread_id, 0);
+		pthread_mutex_destroy(&lock);
+		pluginActivated = 0;
+		result = 0;
+	}  else {
+		pthread_mutex_unlock(&lock);
+	}
+	
+	return result;
+}
+void NumberOfActiveSessions()
+{
+	printf("NumberOfActiveSessions() received \n");
+	printf("active count = %d",get_active_sessions_count());
+}
+
+void DetailsActiveSessions()
+{
+	printf("DetailsActiveSessions() received \n");
+	uint numberOfSession= get_active_sessions_count();
+	struct client_info *sshsession;
+	sshsession = (struct active_clients *)malloc(sizeof(struct client_info)*numberOfSession);
+	get_active_sessions_info(sshsession, numberOfSession);
+	free(sshsession);
+	return ;
+}
+
+/*Add a new client session*/
+void add_new_client(int newpid,const char* remote_host_ip, int handle)
+{
+	time_t now;
+	time(&now);
+	struct active_clients *newclient;
+	newclient = (struct active_clients *)malloc(sizeof(struct active_clients));
+	if(!newclient){
+		printf("libdropbear Error! unable to create a memory for a new active SSH session of type active_clients \n ");
+	}
+	newclient->info.pid = newpid;
+	newclient->info.fileDescriptor = handle;
+	strcpy(newclient->info.ipaddress, remote_host_ip);
+	strcpy(newclient->info.timestamp,ctime(&now));
+	newclient->info.timestamp[strlen(newclient->info.timestamp) - 1 ] = '\0';
+	pthread_mutex_lock(&lock);
+	list_add_tail(&(newclient->client_list),&client_connections_info);
+	fd_children_update=true ;   //signal the children track thread that there is an update
+	pthread_mutex_unlock(&lock);
+
+}
+
+/*Return the number of clients currently connected*/
+uint get_active_sessions_count(){
+	uint count=0;
+	pthread_mutex_lock(&lock);
+	if(pluginActivated){
+		struct active_clients *client;
+		struct list_head *ptr_list;
+		list_for_each(ptr_list,&client_connections_info){
+			client = list_entry(ptr_list,struct active_clients,client_list);
+			if(client){
+				count++;
+			}
+		}
+	}
+	pthread_mutex_unlock(&lock);
+	return count;
+}
+
+/*To get the list of connections that are currently serving*/
+uint  get_active_sessions_info(struct client_info* connectedclientsContainer,size_t connections_count){
+	uint result = 0 ;
+	pthread_mutex_lock(&lock);
+	if(pluginActivated){
+		size_t count = 0;
+		struct active_clients *client;
+		struct list_head *ptr_list;
+		list_for_each(ptr_list,&client_connections_info){
+		client = list_entry(ptr_list, struct active_clients, client_list );
+			if(client && (count < connections_count)){
+				connectedclientsContainer[count].pid=client->info.pid;
+				strcpy(connectedclientsContainer[count].ipaddress,client->info.ipaddress);
+				strcpy(connectedclientsContainer[count].timestamp,client->info.timestamp);
+				TRACE(("pid= %d ip=%s  timestamp=%s",client->info.pid,client->info.ipaddress, client->info.timestamp));
+				count++;
+			} else {
+				break;
+			}
+		}
+		pthread_mutex_unlock(&lock);
+	} else {
+		pthread_mutex_unlock(&lock);
+		result = 1;
+	}
+	return result;
+}
+
+
+void update_child_process_list(){
+	TRACE(("wissemmmm  entering update_child_process_list"));
+	struct active_clients *client;
+	struct list_head *ptr_list;
+	pthread_mutex_lock(&lock);
+	list_for_each(ptr_list, &client_connections_info){
+		client = list_entry(ptr_list,struct active_clients, client_list);
+		if (client){
+			int clientpid= client->info.pid;
+			pthread_mutex_unlock(&lock);
+			if (kill(clientpid,0) ==-1 && (errno==ESRCH) ){  // checkig if the pid has died
+				pthread_mutex_lock(&lock);
+				__list_del_entry(ptr_list);
+				pthread_mutex_unlock(&lock);
+			} 
+		} 
+	}
+	pthread_mutex_unlock(&lock);
+	TRACE(("wissemmmm  leaving update_child_process_list"));
+}
+
+/* To terminate  the server connection to client with the pid  */
+uint  close_client_session(int client_pid){
+	uint result = 0 ;
+	bool pid_existing=false;
+	struct active_clients *client;
+	struct list_head *ptr_list;
+	pthread_mutex_lock(&lock);
+	if(pluginActivated){
+		list_for_each(ptr_list,&client_connections_info){
+			client = list_entry(ptr_list,struct active_clients,client_list);
+			if(client && (client->info.pid == client_pid)){
+				pthread_mutex_unlock(&lock);
+				pid_existing=true;
+				break;
+			}
+		}
+		if(pid_existing == true){
+			if(kill(client_pid,SIGUSR1) !=-1){
+				TRACE(("libbdropbear: successfully closed the process : %d\n",client_pid));
+				pthread_mutex_lock(&lock);
+				//remove the closed session from the list
+				__list_del_entry(ptr_list);
+				pthread_mutex_unlock(&lock);
+			} else {
+				TRACE(("libbdropbear: Failed to  close the process : %d\n",client_pid));
+			}
+		} else {
+			result =1;
+		}
+	} else{
+		pthread_mutex_unlock(&lock);
+		result =2;
+	}
+	return result;
+}
+
+
+/* remove client session with fd= closedfd  */
+uint  remove_client_session_fd(int closedfd){
+	uint result = 0 ;
+	bool fd_existing=false;
+	struct active_clients *client;
+	struct list_head *ptr_list;
+	pthread_mutex_lock(&lock);
+	list_for_each(ptr_list,&client_connections_info){
+		client = list_entry(ptr_list,struct active_clients,client_list);
+		if(client && (client->info.fileDescriptor == closedfd)){
+			fd_existing=true;
+			break;
+		}
+	}
+	pthread_mutex_unlock(&lock);
+	if(fd_existing == true){
+		pthread_mutex_lock(&lock);
+		__list_del_entry(ptr_list);
+		pthread_mutex_unlock(&lock);
+	} else {
+		TRACE(("libbdropbear: Trying to  close a NON existing fd! "));
+		result =1;
+	}
+
+	return result;
+}
+
+
+
+void free_client_info(){
+	struct active_clients *client;
+	struct list_head *ptr_list;
+	pthread_mutex_lock(&lock);
+	list_for_each(ptr_list, &client_connections_info){
+		client = list_entry(ptr_list,struct active_clients, client_list);
+		if (client){
+			int clientpid= client->info.pid;
+			pthread_mutex_unlock(&lock);
+			if (kill(clientpid,SIGUSR1) ==true ){
+				pthread_mutex_lock(&lock);
+				__list_del_entry(ptr_list);
+				pthread_mutex_unlock(&lock);
+			} else {
+				TRACE(("libbdropbear: Failed to  close the process in free_client_info: %d\n",clientpid));
+			}
+		} 
+	}
+	pthread_mutex_unlock(&lock);
+}
+
+
+
+
 
 #if INETD_MODE
 static void main_inetd() {
@@ -113,7 +491,7 @@ static void main_inetd() {
 #endif /* INETD_MODE */
 
 #if NON_INETD_MODE
-static void main_noinetd() {
+static void* main_noinetd(void* nonused) {
 	fd_set fds;
 	unsigned int i, j;
 	int val;
@@ -127,6 +505,7 @@ static void main_noinetd() {
 
 	int childsock;
 	int childpipe[2];
+	int childpipe_track_exit[2];
 
 	/* Note: commonsetup() must happen before we daemon()ise. Otherwise
 	   daemon() will chdir("/"), and we won't be able to find local-dir
@@ -150,7 +529,9 @@ static void main_noinetd() {
 		FD_SET(listensocks[i], &fds);
 	}
 
-	/* fork */
+	/* fork 
+	wissemmmm to enable back on final revision
+	/*
 	if (svr_opts.forkbg) {
 		int closefds = 0;
 #if !DEBUG_TRACE
@@ -162,13 +543,15 @@ static void main_noinetd() {
 			dropbear_exit("Failed to daemonize: %s", strerror(errno));
 		}
 	}
+	
 
-	/* should be done after syslog is working */
+	/* should be done after syslog is working 
 	if (svr_opts.forkbg) {
 		dropbear_log(LOG_INFO, "Running in background");
 	} else {
 		dropbear_log(LOG_INFO, "Not backgrounding");
 	}
+	*/
 
 	/* create a PID file so that we can be killed easily */
 	pidfile = fopen(svr_opts.pidfile, "w");
@@ -177,11 +560,17 @@ static void main_noinetd() {
 		fclose(pidfile);
 	}
 
+	// We need to track the child processes and using SIGCHLD does not properly when dropbear is built as a shated lib and loaded by WPEProcess
+	if (pthread_create(&children_routine_thread_id,NULL,track_child_process_routine,NULL) != 0){
+		TRACE(("libdropbear Error : creation of track_child_process_routine Failed!"));
+		pthread_exit("creation of track_child_process_routine Failed!");
+	}
+
 	/* incoming connection select loop */
 	for(;;) {
 
 		DROPBEAR_FD_ZERO(&fds);
-		
+
 		/* listening sockets */
 		for (i = 0; i < listensockcount; i++) {
 			FD_SET(listensocks[i], &fds);
@@ -194,16 +583,28 @@ static void main_noinetd() {
 				maxsock = MAX(maxsock, childpipes[i]);
 			}
 		}
+		struct timeval timeout;
+		timeout.tv_sec = 5;
+		timeout.tv_usec = 0;
 
-		val = select(maxsock+1, &fds, NULL, NULL, NULL);
+		val = select(maxsock+1, &fds, NULL, NULL, &timeout);
 
-		if (ses.exitflag) {
-			unlink(svr_opts.pidfile);
-			dropbear_exit("Terminated by signal");
-		}
-		
 		if (val == 0) {
-			/* timeout reached - shouldn't happen. eh */
+			//Timedout
+
+			//Check if a stop_server command received or a system termination signal
+			pthread_mutex_lock(&lock);
+			if (stop_server == true || ses.exitflag){  
+				pthread_mutex_unlock(&lock);
+				//first close all clients open sessions
+				free_client_info();
+				unlink(svr_opts.pidfile);
+				
+				dropbear_exit("Terminated by signal or by a command");
+			} else {
+				pthread_mutex_unlock(&lock);
+			}
+
 			continue;
 		}
 
@@ -274,6 +675,10 @@ static void main_noinetd() {
 				TRACE(("error creating child pipe"))
 				goto out;
 			}
+			if (pipe(childpipe_track_exit) < 0) {
+				TRACE(("error creating child pipe"))
+				goto out;
+			}
 
 #if DEBUG_NOFORK
 			fork_ret = 0;
@@ -290,6 +695,11 @@ static void main_noinetd() {
 			if (fork_ret > 0) {
 
 				/* parent */
+
+				/* New SHH client --> add it to our tracking list */
+				add_new_client(fork_ret,remote_host,childpipe_track_exit[0]);
+				m_close(childpipe_track_exit[1]);  // no need for the write end
+
 				childpipes[conn_idx] = childpipe[0];
 				m_close(childpipe[1]);
 				preauth_addrs[conn_idx] = remote_host;
@@ -315,7 +725,18 @@ static void main_noinetd() {
 				}
 
 				m_close(childpipe[0]);
-
+				m_close(childpipe_track_exit[0]);
+				/* child process does not need the track_child_process_routine , thus cancel it */
+				int s = pthread_cancel(children_routine_thread_id);
+				if (s != 0)
+					TRACE(("libdropbear: error: failed to cancel the  track_child_process_routine thread"));
+
+				// ONLY for client SSH sessions :user signal to close the active SSH session
+				if (signal(SIGUSR1, sigusr1_handler) == SIG_ERR) {
+					TRACE(("libdropbear: error: failed to setup sigusr1_handler "));
+					dropbear_exit("libdropbear error : sigusr1_handler failed");
+				}
+			
 				/* start the session */
 				svr_session(childsock, childpipe[1]);
 				/* don't return */
@@ -331,8 +752,78 @@ out:
 		}
 	} /* for(;;) loop */
 
+	return NULL;
 	/* don't reach here */
 }
+
+static void* track_child_process_routine(void* nonused) 
+{
+	struct pollfd* pfds =NULL;
+	uint  timeout = 5;   // 5s timeout for the poll
+	uint numberOfSession = 0 ;
+	TRACE(("wissemmmmmmmmmmmmmmmmmmmmmmmm entering  track_child_process_routine"));
+
+	
+	while (true){
+		pthread_mutex_lock(&lock);
+		if(stop_server == true || ses.exitflag) {
+			pthread_mutex_unlock(&lock);
+			break;
+		}
+		if (fd_children_update == true) {
+			TRACE(("wissemmmmmmmmmmmmmmmmmmmmmmmm update for  track_child_process_routine"));
+			fd_children_update = false; 
+			pthread_mutex_unlock(&lock);
+			free(pfds);
+			numberOfSession = get_active_sessions_count();
+			pfds=calloc(numberOfSession, sizeof(struct pollfd));
+			if (pfds == NULL){
+				TRACE(("libdropbear Error in calloc track_child_process_routine"))
+			}
+			// fill in the pfds
+			size_t count=0;
+			struct active_clients *client;
+			struct list_head *ptr_list;
+			pthread_mutex_lock(&lock);
+			list_for_each(ptr_list,&client_connections_info){
+				client = list_entry(ptr_list,struct active_clients,client_list);
+				if(client){
+					pfds[count].fd = client->info.fileDescriptor;
+					pfds[count].events = POLLHUP | POLLIN | POLLERR;  // only interested in the closing conenction events
+					count++;
+				}
+			}
+			pthread_mutex_unlock(&lock);
+		} else {
+			pthread_mutex_unlock(&lock);
+		}
+
+		// Now start polling and block
+		int result = poll(pfds, numberOfSession, timeout*1000);
+
+		if (result > 0) {
+			TRACE(("wissemmmmmmmmmmmmmmmmm poll result>0 %d",result));
+			for(size_t i=0; i < numberOfSession; i++) {
+				if (pfds[i].revents & (POLLHUP | POLLIN | POLLERR)){
+					TRACE(("wissemmmmmmmmmmmmmmmmm connection out"));
+					remove_client_session_fd(pfds[i].fd);
+					m_close(pfds[i].fd);
+					fd_children_update = true ;
+				}
+			}
+			
+		}else if (result==-1){
+			TRACE(("wissemmmmmmmmmmmmmmmmm poll result returned negatif wit error = %d!! ",errno));
+		}
+	}
+	if(pfds)free(pfds); 
+	TRACE(("wissemmmmmmmmmmmmmmmmmmmmmmmm thread exit for  track_child_process_routine"));
+	return NULL;
+
+}
+	
+	
+
 #endif /* NON_INETD_MODE */
 
 
@@ -342,6 +833,7 @@ static void sigchld_handler(int UNUSED(unused)) {
 
 	const int saved_errno = errno;
 
+
 	while(waitpid(-1, NULL, WNOHANG) > 0) {}
 
 	sa_chld.sa_handler = sigchld_handler;
@@ -362,7 +854,7 @@ static void sigsegv_handler(int UNUSED(unused)) {
 
 /* catch ctrl-c or sigterm */
 static void sigintterm_handler(int UNUSED(unused)) {
-
+	printf("wissemmmmmmmmmmmm sigintterm_handler signal \n ");
 	ses.exitflag = 1;
 }
 
@@ -411,7 +903,7 @@ static size_t listensockets(int *socks, size_t sockcount, int *maxfd) {
 	size_t sockpos = 0;
 	int nsock;
 
-	TRACE(("listensockets: %d to try", svr_opts.portcount))
+	TRACE(("listensockets: %d to try", svr_opts.portcount));
 
 	for (i = 0; i < svr_opts.portcount; i++) {
 
 

