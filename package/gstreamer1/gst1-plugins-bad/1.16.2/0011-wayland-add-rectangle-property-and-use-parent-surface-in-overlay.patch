diff -urN gst-plugins-bad-1.16.1/ext/wayland/gstwaylandsink.c gst-plugins-bad-1.16.1-mod/ext/wayland/gstwaylandsink.c
--- gst-plugins-bad-1.16.1/ext/wayland/gstwaylandsink.c	2021-07-28 08:25:03.936860644 -0700
+++ gst-plugins-bad-1.16.1-mod/ext/wayland/gstwaylandsink.c	2021-08-06 08:10:36.151106391 -0700
@@ -62,7 +62,8 @@
 {
   PROP_0,
   PROP_DISPLAY,
-  PROP_FULLSCREEN
+  PROP_FULLSCREEN,
+  PROP_WINDOW_SET
 };
 
 GST_DEBUG_CATEGORY (gstwayland_debug);
@@ -208,6 +209,12 @@
       g_param_spec_boolean ("fullscreen", "Fullscreen",
           "Whether the surface should be made fullscreen ", FALSE,
           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
+  g_object_class_install_property (G_OBJECT_CLASS (klass), PROP_WINDOW_SET,
+       g_param_spec_string ("rectangle", "rectangle",
+           "Window Set Format: x,y,width,height",
+           NULL, G_PARAM_WRITABLE));
+
 }
 
 static void
@@ -269,6 +276,36 @@
       gst_wayland_sink_set_fullscreen (sink, g_value_get_boolean (value));
       GST_OBJECT_UNLOCK (sink);
       break;
+    case PROP_WINDOW_SET:
+    {
+      const gchar *str= g_value_get_string(value);
+      gchar **parts= g_strsplit(str, ",", 4);
+
+      if ( !parts[0] || !parts[1] || !parts[2] || !parts[3] ) {
+        GST_ERROR( "Bad window properties string" );
+      } else {
+        int nx, ny, nw, nh;
+        nx= atoi( parts[0] );
+        ny= atoi( parts[1] );
+        nw= atoi( parts[2] );
+        nh= atoi( parts[3] );
+
+        if ( sink->window ) {
+	  if ( (sink->window->configured == TRUE) &&
+  	       ((nx != sink->windowX) ||
+               (ny != sink->windowY) ||
+               (nw != sink->windowWidth) ||
+               (nh != sink->windowHeight)) ) {
+             sink->windowX= nx;
+             sink->windowY= ny;
+             sink->windowWidth= nw;
+             sink->windowHeight= nh;
+             gst_wl_window_set_render_rectangle(sink->window, nx, ny, nw, nh);
+	   }
+	}
+      }
+      break;
+    }
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
@@ -394,12 +431,16 @@
     case GST_STATE_CHANGE_PAUSED_TO_READY:
       gst_buffer_replace (&sink->last_buffer, NULL);
       if (sink->window) {
+#if 0
         if (gst_wl_window_is_toplevel (sink->window)) {
           g_clear_object (&sink->window);
         } else {
           /* remove buffer from surface, show nothing */
           gst_wl_window_render (sink->window, NULL, NULL);
         }
+#else
+        g_clear_object (&sink->window);
+#endif
       }
       break;
     case GST_STATE_CHANGE_READY_TO_NULL:
@@ -1042,7 +1083,7 @@
 
   gst_wl_shm_allocator_register ();
 
-  return gst_element_register (plugin, "waylandsink", GST_RANK_MARGINAL,
+  return gst_element_register (plugin, "waylandsink", GST_RANK_PRIMARY,
       GST_TYPE_WAYLAND_SINK);
 }
 
diff -urN gst-plugins-bad-1.16.1/ext/wayland/gstwaylandsink.h gst-plugins-bad-1.16.1-mod/ext/wayland/gstwaylandsink.h
--- gst-plugins-bad-1.16.1/ext/wayland/gstwaylandsink.h	2019-04-19 02:16:36.000000000 -0700
+++ gst-plugins-bad-1.16.1-mod/ext/wayland/gstwaylandsink.h	2021-08-06 07:45:39.378046071 -0700
@@ -62,6 +62,11 @@
   GstVideoInfo video_info;
   gboolean fullscreen;
 
+  gint windowX;
+  gint windowY;
+  gint windowWidth;
+  gint windowHeight;
+
   gchar *display_name;
 
   gboolean redraw_pending;
diff -urN gst-plugins-bad-1.16.1/ext/wayland/wldisplay.c gst-plugins-bad-1.16.1-mod/ext/wayland/wldisplay.c
--- gst-plugins-bad-1.16.1/ext/wayland/wldisplay.c	2019-04-19 02:16:36.000000000 -0700
+++ gst-plugins-bad-1.16.1-mod/ext/wayland/wldisplay.c	2021-08-06 08:09:48.557144716 -0700
@@ -61,6 +61,12 @@
   if (self->thread)
     g_thread_join (self->thread);
 
+  wl_display_roundtrip_queue (self->display, self->queue);
+
+  if (self->queue) {
+    wl_event_queue_destroy (self->queue);
+  }
+
   /* to avoid buffers being unregistered from another thread
    * at the same time, take their ownership */
   g_mutex_lock (&self->buffers_mutex);
@@ -108,9 +114,6 @@
   if (self->display_wrapper)
     wl_proxy_wrapper_destroy (self->display_wrapper);
 
-  if (self->queue)
-    wl_event_queue_destroy (self->queue);
-
   if (self->own_display) {
     wl_display_flush (self->display);
     wl_display_disconnect (self->display);
@@ -264,6 +267,7 @@
     }
     if (wl_display_read_events (self->display) == -1)
       goto error;
+
     wl_display_dispatch_queue_pending (self->display, self->queue);
   }
 
@@ -357,7 +361,6 @@
     g_warning ("Could not bind to either wl_shell, xdg_wm_base or "
         "zwp_fullscreen_shell, video display may not work properly.");
   }
-
   self->thread = g_thread_try_new ("GstWlDisplay", gst_wl_display_thread_run,
       self, &err);
   if (err) {
diff -urN gst-plugins-bad-1.16.1/ext/wayland/wlwindow.c gst-plugins-bad-1.16.1-mod/ext/wayland/wlwindow.c
--- gst-plugins-bad-1.16.1/ext/wayland/wlwindow.c	2021-08-06 08:02:22.821151406 -0700
+++ gst-plugins-bad-1.16.1-mod/ext/wayland/wlwindow.c	2021-08-06 08:08:53.628380339 -0700
@@ -203,8 +203,10 @@
   window->video_surface_wrapper =
       wl_proxy_create_wrapper (window->video_surface);
 
-  wl_proxy_set_queue ((struct wl_proxy *) window->area_surface_wrapper,
-      display->queue);
+  if (window->display->own_display) {
+    wl_proxy_set_queue ((struct wl_proxy *) window->area_surface_wrapper,
+          display->queue);
+  }
   wl_proxy_set_queue ((struct wl_proxy *) window->video_surface_wrapper,
       display->queue);
 
@@ -214,9 +216,14 @@
       window->video_surface, window->area_surface);
   wl_subsurface_set_desync (window->video_subsurface);
 
+  wl_subsurface_place_below(window->video_subsurface, window->area_surface);
   if (display->viewporter) {
-    window->area_viewport = wp_viewporter_get_viewport (display->viewporter,
-        window->area_surface);
+    if (window->display->own_display) {
+      window->area_viewport = wp_viewporter_get_viewport (display->viewporter,
+      window->area_surface);
+    } else {
+      window->area_viewport = NULL;
+    }
     window->video_viewport = wp_viewporter_get_viewport (display->viewporter,
         window->video_surface);
   }
@@ -344,6 +351,9 @@
       window->area_surface, parent);
   wl_subsurface_set_desync (window->area_subsurface);
 
+  wl_subsurface_place_below(window->area_subsurface, parent);
+  wl_surface_commit (parent);
+
   return window;
 }
 
@@ -448,7 +458,8 @@
 
     wl_subsurface_set_sync (window->video_subsurface);
     gst_wl_window_resize_video_surface (window, FALSE);
-    gst_wl_window_set_opaque (window, info);
+    if (window->display->own_display)
+      gst_wl_window_set_opaque (window, info);
   }
 
   if (G_LIKELY (buffer))
diff -urN gst-plugins-bad-1.16.1/gst-libs/gst/wayland/meson.build gst-plugins-bad-1.16.1-mod/gst-libs/gst/wayland/meson.build
--- gst-plugins-bad-1.16.1/gst-libs/gst/wayland/meson.build	2019-04-19 02:16:36.000000000 -0700
+++ gst-plugins-bad-1.16.1-mod/gst-libs/gst/wayland/meson.build	2021-08-08 23:24:36.584196795 -0700
@@ -21,4 +21,9 @@
   gstwayland_dep = declare_dependency(link_with : gstwayland,
     include_directories : [libsinc],
     dependencies : [gst_dep, gstvideo_dep])
+
+  gstwayland_headers = [
+  'wayland.h',
+  ]
+  install_headers(gstwayland_headers, subdir : 'gstreamer-' + api_version + '/gst/wayland/')
 endif
