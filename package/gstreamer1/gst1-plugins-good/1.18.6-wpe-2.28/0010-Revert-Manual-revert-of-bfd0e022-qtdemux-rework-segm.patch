From 7ff05024af2b00a70adb3eb26a5b9b94f5f5046d Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Enrique=20Oca=C3=B1a=20Gonz=C3=A1lez?= <eocanha@igalia.com>
Date: Thu, 14 Jul 2022 13:50:28 +0200
Subject: [PATCH 4/5] Revert "Manual revert of bfd0e022 qtdemux: rework segment
 event pushing"

This reverts commit e919519fbe04cf19c4a1390ab07c56b080bb43c7.
---
 gst/isomp4/qtdemux.c | 78 +++++++++++---------------------------------
 gst/isomp4/qtdemux.h |  7 ++--
 2 files changed, 24 insertions(+), 61 deletions(-)

diff --git a/gst/isomp4/qtdemux.c b/gst/isomp4/qtdemux.c
index c7b77d9aa..b2aad2af5 100644
--- a/gst/isomp4/qtdemux.c
+++ b/gst/isomp4/qtdemux.c
@@ -1998,9 +1998,6 @@ gst_qtdemux_reset (GstQTDemux * qtdemux, gboolean hard)
     qtdemux->element_index = NULL;
 #endif
     qtdemux->major_brand = 0;
-    if (qtdemux->pending_newsegment)
-      gst_event_unref (qtdemux->pending_newsegment);
-    qtdemux->pending_newsegment = NULL;
     qtdemux->upstream_format_is_time = FALSE;
     qtdemux->upstream_seekable = FALSE;
     qtdemux->upstream_size = 0;
@@ -2023,6 +2020,7 @@ gst_qtdemux_reset (GstQTDemux * qtdemux, gboolean hard)
   qtdemux->offset = 0;
   gst_adapter_clear (qtdemux->adapter);
   gst_segment_init (&qtdemux->segment, GST_FORMAT_TIME);
+  qtdemux->need_segment = TRUE;
 
   if (hard) {
     qtdemux->segment_seqnum = GST_SEQNUM_INVALID;
@@ -2068,12 +2066,6 @@ gst_qtdemux_reset (GstQTDemux * qtdemux, gboolean hard)
       stream->accumulated_base = 0;
       stream->last_keyframe_dts = GST_CLOCK_TIME_NONE;
     }
-    if (!qtdemux->pending_newsegment) {
-      qtdemux->pending_newsegment = gst_event_new_segment (&qtdemux->segment);
-      if (qtdemux->segment_seqnum != GST_SEQNUM_INVALID)
-        gst_event_set_seqnum (qtdemux->pending_newsegment,
-            qtdemux->segment_seqnum);
-    }
   }
 }
 
@@ -2168,12 +2160,7 @@ gst_qtdemux_handle_sink_event (GstPad * sinkpad, GstObject * parent,
       GST_DEBUG_OBJECT (demux, "received newsegment %" GST_SEGMENT_FORMAT,
           &segment);
 
-      /* erase any previously set segment */
-      gst_event_replace (&demux->pending_newsegment, NULL);
-
       if (segment.format == GST_FORMAT_TIME) {
-        GST_DEBUG_OBJECT (demux, "new pending_newsegment");
-        gst_event_replace (&demux->pending_newsegment, event);
         demux->upstream_format_is_time = TRUE;
         demux->segment_seqnum = gst_event_get_seqnum (event);
       } else {
@@ -2250,16 +2237,8 @@ gst_qtdemux_handle_sink_event (GstPad * sinkpad, GstObject * parent,
 
       /* map segment to internal qt segments and push on each stream */
       if (QTDEMUX_N_STREAMS (demux)) {
-        if (demux->fragmented) {
-          GstEvent *segment_event = gst_event_new_segment (&segment);
-
-          gst_event_replace (&demux->pending_newsegment, NULL);
-          gst_event_set_seqnum (segment_event, demux->segment_seqnum);
-          gst_qtdemux_push_event (demux, segment_event);
-        } else {
-          gst_event_replace (&demux->pending_newsegment, NULL);
-          gst_qtdemux_map_and_push_segments (demux, &segment);
-        }
+        demux->need_segment = TRUE;
+        gst_qtdemux_check_send_pending_segment (demux);
       }
 
       /* clear leftover in current segment, if any */
@@ -4215,6 +4194,12 @@ qtdemux_parse_moof (GstQTDemux * qtdemux, const guint8 * buffer, guint length,
       QtDemuxStream *stream = QTDEMUX_NTH_STREAM (qtdemux, i);
       stream->time_position = min_dts;
     }
+
+    /* Before this code was run a segment was already sent when the moov was
+     * parsed... which is OK -- some apps (mostly tests) expect a segment to
+     * be emitted after a moov, and we can emit a second segment anyway for
+     * special cases like this. */
+    qtdemux->need_segment = TRUE;
   }
 
   qtdemux->first_moof_already_parsed = TRUE;
@@ -6861,7 +6846,7 @@ gst_qtdemux_drop_data (GstQTDemux * demux, gint bytes)
 static void
 gst_qtdemux_check_send_pending_segment (GstQTDemux * demux)
 {
-  if (G_UNLIKELY (demux->pending_newsegment)) {
+  if (G_UNLIKELY (demux->need_segment)) {
     gint i;
 
     if (!demux->upstream_format_is_time) {
@@ -6874,6 +6859,8 @@ gst_qtdemux_check_send_pending_segment (GstQTDemux * demux)
       gst_qtdemux_push_event (demux, segment_event);
     }
 
+    demux->need_segment = FALSE;
+
     /* clear to send tags on all streams */
     for (i = 0; i < QTDEMUX_N_STREAMS (demux); i++) {
       QtDemuxStream *stream = QTDEMUX_NTH_STREAM (demux, i);
@@ -7173,15 +7160,6 @@ gst_qtdemux_process_adapter (GstQTDemux * demux, gboolean force)
               if (demux->moov_node)
                 g_node_destroy (demux->moov_node);
               demux->moov_node = NULL;
-            } else {
-              /* prepare newsegment to send when streaming actually starts */
-              if (!demux->pending_newsegment) {
-                demux->pending_newsegment =
-                    gst_event_new_segment (&demux->segment);
-                if (demux->segment_seqnum != GST_SEQNUM_INVALID)
-                  gst_event_set_seqnum (demux->pending_newsegment,
-                      demux->segment_seqnum);
-              }
             }
 
             demux->last_moov_offset = demux->offset;
@@ -7200,8 +7178,7 @@ gst_qtdemux_process_adapter (GstQTDemux * demux, gboolean force)
 
             demux->got_moov = TRUE;
 
-            gst_event_replace (&demux->pending_newsegment, NULL);
-            gst_qtdemux_map_and_push_segments (demux, &demux->segment);
+            gst_qtdemux_check_send_pending_segment (demux);
 
             if (demux->moov_node_compressed) {
               g_node_destroy (demux->moov_node_compressed);
@@ -7284,20 +7261,15 @@ gst_qtdemux_process_adapter (GstQTDemux * demux, gboolean force)
               ret = GST_FLOW_ERROR;
               goto done;
             }
+
             /* in MSS we need to expose the pads after the first moof as we won't get a moov */
             if (demux->variant == VARIANT_MSS_FRAGMENTED && !demux->exposed) {
-              if (!demux->pending_newsegment) {
-                GST_DEBUG_OBJECT (demux, "new pending_newsegment");
-                demux->pending_newsegment =
-                    gst_event_new_segment (&demux->segment);
-                if (demux->segment_seqnum != GST_SEQNUM_INVALID)
-                  gst_event_set_seqnum (demux->pending_newsegment,
-                      demux->segment_seqnum);
-              }
               QTDEMUX_EXPOSE_LOCK (demux);
               qtdemux_expose_streams (demux);
               QTDEMUX_EXPOSE_UNLOCK (demux);
             }
+
+            gst_qtdemux_check_send_pending_segment (demux);
           } else {
             GST_DEBUG_OBJECT (demux, "Discarding [moof]");
           }
@@ -13216,14 +13188,6 @@ qtdemux_update_streams (GstQTDemux * qtdemux)
       stream->stream_tags = NULL;
       if (!gst_qtdemux_add_stream (qtdemux, stream, list))
         return FALSE;
-
-      /* New segment will be exposed at _update_segment in case of pull mode */
-      if (!qtdemux->pending_newsegment && !qtdemux->pullbased) {
-        qtdemux->pending_newsegment = gst_event_new_segment (&qtdemux->segment);
-        if (qtdemux->segment_seqnum)
-          gst_event_set_seqnum (qtdemux->pending_newsegment,
-              qtdemux->segment_seqnum);
-      }
     }
   }
 
@@ -13248,6 +13212,7 @@ qtdemux_expose_streams (GstQTDemux * qtdemux)
     }
 
     g_ptr_array_set_size (qtdemux->old_streams, 0);
+    qtdemux->need_segment = TRUE;
 
     return GST_FLOW_OK;
   }
@@ -13266,13 +13231,6 @@ qtdemux_expose_streams (GstQTDemux * qtdemux)
       if (!gst_qtdemux_add_stream (qtdemux, stream, list))
         return GST_FLOW_ERROR;
 
-      /* New segment will be exposed at _update_segment in case of pull mode */
-      if (!qtdemux->pending_newsegment && !qtdemux->pullbased) {
-        qtdemux->pending_newsegment = gst_event_new_segment (&qtdemux->segment);
-        if (qtdemux->segment_seqnum)
-          gst_event_set_seqnum (qtdemux->pending_newsegment,
-              qtdemux->segment_seqnum);
-      }
     }
   }
 
@@ -13318,6 +13276,8 @@ qtdemux_expose_streams (GstQTDemux * qtdemux)
   g_ptr_array_foreach (qtdemux->active_streams,
       (GFunc) qtdemux_do_allocation, qtdemux);
 
+  qtdemux->need_segment = TRUE;
+
   qtdemux->exposed = TRUE;
   return GST_FLOW_OK;
 }
diff --git a/gst/isomp4/qtdemux.h b/gst/isomp4/qtdemux.h
index 2c0d04086..e7978b557 100644
--- a/gst/isomp4/qtdemux.h
+++ b/gst/isomp4/qtdemux.h
@@ -140,8 +140,11 @@ struct _GstQTDemux {
   /* State for key_units trickmode */
   GstClockTime trickmode_interval;
 
-  /* The SEGMENT_EVENT from upstream *OR* generated from segment (above) */
-  GstEvent *pending_newsegment;
+  /* PUSH-BASED only: If the initial segment event, or a segment consequence of
+   * a seek or incoming TIME segment from upstream needs to be pushed. This
+   * variable is used instead of pushing the event directly because at that
+   * point we may not have yet emitted the srcpads. */
+  gboolean need_segment;
 
   guint32 segment_seqnum;
 
-- 
2.34.1

